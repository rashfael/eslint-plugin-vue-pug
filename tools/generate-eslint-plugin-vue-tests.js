const fs = require('fs')
const path = require('path')
const { convert: html2Pug } = require('xhtml2pug')
const { parse: parseVue } = require('@vue/compiler-dom')
const SOURCE_BASE_PATH = path.resolve(
  __dirname,
  '../eslint-plugin-vue/tests/lib/rules/'
)
const TARGET_BASE_PATH = path.resolve(
  __dirname,
  '../tests/eslint-plugin-vue/rules/'
)

const ESLINT_PLUGIN_VUE_GIT_REF = fs
  .readFileSync(
    path.resolve(
      __dirname,
      '../.git/modules/eslint-plugin-vue/refs/heads/master'
    ),
    'utf8'
  )
  .trim()

function getHeader(testname) {
  return `// AUTOGENERATED FROM https://github.com/vuejs/eslint-plugin-vue/blob/${ESLINT_PLUGIN_VUE_GIT_REF}/tests/lib/rules/${testname}.js\n`
}

const IGNORE_TESTS = [
  'array-bracket-newline',
  'comment-directive', // invalid syntax breaks the autoconverter
  'html-closing-bracket-spacing',
  'html-closing-bracket-newline',
  'html-comment-content-newline',
  'html-comment-content-spacing',
  'html-comment-indent',
  'html-end-tags',
  'html-indent',
  'html-self-closing',
  'multiline-html-element-content-newline',
  'no-irregular-whitespace', // will probably die horribly
  'no-parsing-error', // need to do own pug parser tests
  'component-name-in-template-casing', // fixes break pug
  'max-attributes-per-line', // fixes break pug
  'max-len', // fixes break pug
  'no-child-content', // does not clean up whitespace, but this might be because we're not using HTMLWhitespace
  'no-multi-spaces', // Error type should be HTMLIdentifier, found PugIdentifier

  // tests without template content rules
  'block-lang',
  'no-restricted-call-after-await',
  'script-indent',
  'component-api-style',
  'component-definition-name-casing',
  'component-options-name-casing',
  'component-tags-order',
  'experimental-script-setup-vars',
  'jsx-uses-vars',
  'multi-word-component-names',
  'name-property-casing',
  'new-line-between-multi-line-property',
  'next-tick-style',
  'no-arrow-functions-in-watch',
  'no-async-in-computed-properties',
  'no-boolean-default',
  'no-computed-properties-in-data',
  'no-deprecated-data-object-declaration',
  'no-deprecated-destroyed-lifecycle',
  'no-deprecated-events-api',
  'no-deprecated-vue-config-keycodes',
  'no-dupe-keys',
  'no-empty-component-block',
  'no-export-in-script-setup',
  'no-expose-after-await',
  'no-invalid-model-keys',
  'no-lifecycle-after-await',
  'no-multiple-slot-args',
  'no-potential-component-option-typo',
  'no-ref-as-operand',
  'no-reserved-props',
  'no-restricted-block',
  'no-restricted-component-options',
  'no-restricted-props',
  'no-setup-props-destructure',
  'no-shared-component-data',
  'no-side-effects-in-computed-properties',
  'one-component-per-file',
  'prefer-import-from-vue',
  'prop-name-casing',
  'require-direct-export',
  'require-expose',
  'require-name-property',
  'require-prop-type-constructor',
  'require-render-return',
  'require-slots-as-functions',
  'return-in-computed-property',
  'return-in-emits-validator',
  'valid-define-emits',
  'valid-define-props',
  'valid-next-tick'
]

let ruleTests = fs
  .readdirSync(SOURCE_BASE_PATH)
  .filter((file) => file.endsWith('.js'))
  .map((file) => file.replace('.js', ''))
  .filter((file) => !IGNORE_TESTS.includes(file))

function stripIndent(code) {
  const match = code.match(/^[ \t]*(?=\S)/gm)
  if (match[0] === '') match.shift() // ignore first line if not indented
  const indent =
    match && match.length
      ? match.reduce((i, a) => Math.min(i, a.length), Infinity)
      : 0
  if (indent === 0) return code
  return code.replace(new RegExp(`^[ \\t]{${indent}}`, 'gm'), '')
}

function convertCode(code) {
  try {
    const ast = parseVue(code)
    for (const node of ast.children) {
      if (node.tag !== 'template' || node.children.length === 0) continue
      const templateContent = code.slice(
        node.children[0].loc.start.offset,
        node.children[node.children.length - 1].loc.end.offset
      )
      let convertedTemplate = html2Pug(stripIndent(templateContent), {
        bodyLess: true,
        parser: 'vue'
      })
      // fix borked empty attributes
      convertedTemplate = convertedTemplate
        .replaceAll('=,', '="",')
        .replaceAll(/([^\\])([`$])/g, '$1\\$2')
        .replaceAll(/([^\\])([`$])/g, '$1\\$2') // MULTIPASS
        .trim()
      const isMultiline = convertedTemplate.includes('\n')
      code = `${code.slice(0, node.loc.start.offset)}<template lang="pug"${code
        .slice(node.loc.start.offset + 9, node.children[0].loc.start.offset)
        .trimEnd()}${isMultiline ? '\n' : ''}${convertedTemplate}${
        isMultiline ? '\n' : ''
      }${code
        .slice(node.children[node.children.length - 1].loc.end.offset)
        .trim()}`
    }
    return code
  } catch (error) {
    return `<!-- CONVERT ERROR -->${error.message.replaceAll(
      /([^\\])`/g,
      '$1\\`'
    )}${code}`
  }
}

if (process.argv[2]) ruleTests = [process.argv[2]]

for (const testname of ruleTests) {
  let test = fs.readFileSync(
    path.join(SOURCE_BASE_PATH, `${testname}.js`),
    'utf8'
  )
  const target = path.join(TARGET_BASE_PATH, `${testname}.js`)
  try {
    const targetContent = fs.readFileSync(target, 'utf8')
    if (targetContent.startsWith('// SKIP AUTOGENERATION')) {
      console.log('Skipping rule:', testname)
      continue
    }
  } catch (error) {}
  console.log('Generating test for rule:', testname)

  // some lazy replaces
  test = test
    .replaceAll(
      "require('../../../lib",
      "require('../../../eslint-plugin-vue/lib"
    )
    .replace(
      "require('../../eslint-compat",
      "require('../../../eslint-plugin-vue/tests/eslint-compat"
    )
    .replaceAll(
      /parserOptions: {(.*?)}/gs,
      "parserOptions: {$1, templateTokenizer: { pug: 'vue-eslint-parser-template-tokenizer-pug'}}"
    )
    // .replaceAll(/(code|output): ''|^(?!.*\/\/)(.*?)(code|output):\s*(['"`])(.*?[^\\])\4/gs, (match, bad, lineStart, attribute, quotes, code) => {
    // 	if (!code) return match
    // 	return `${lineStart}${attribute}: \`${convertCode(code)}\``
    // })
    // try to get simple test cases
    .replaceAll(
      /^(?!.*[^:]\/\/)(.*?)(['"`])(\s*?<template>[^'"`](.|\n)*?[^\\])\2/gm,
      (match, lineStart, quotes, code) => {
        return `${lineStart}\`${convertCode(code)}\``
      }
    )
    // try to catch stragglers with other tags befor template
    .replaceAll(/^ *<template>.*?<\/template>/gms, (match) =>
      convertCode(match)
    )
  fs.writeFileSync(target, getHeader(testname) + test)
}
